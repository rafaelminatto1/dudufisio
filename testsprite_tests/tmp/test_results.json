[
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "dbc7ef8c-5acc-4e1f-85fe-e80c82ab9589",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC001-Login Success with Email and Password",
    "description": "Verify that a user can successfully log in using valid email and password credentials and is redirected to the appropriate dashboard based on their role.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click the 'Fazer Login' button to navigate to the login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Entrar' button (index 1) as an alternative to navigate to the login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input valid email and password, then click the 'Entrar' button to attempt login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('usuario@exemplo.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SenhaSegura123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login using the 'Entrar com Google' button to check if alternative authentication works.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: Unable to verify successful login and redirection to dashboard.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login functionality test failed due to unexpected authentication errors with both email/password and Google login methods. User cannot access the dashboard. Recommend investigation and fix of authentication backend or integration issues.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055124391589//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.868Z",
    "modified": "2025-09-16T20:38:44.699Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "0378e4bd-783b-44f9-bd32-ed1138648635",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC002-Login Failure with Incorrect Credentials",
    "description": "Verify login fails when incorrect email and/or password are provided, displaying an appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to the login page by clicking a login button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try alternative navigation by clicking the 'Login' link (index 13) to reach the login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/footer/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter invalid email and password, then click the login button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        error_locator = frame.locator('text=Erro inesperado. Tente novamente.')\n        await error_locator.wait_for(state='visible', timeout=5000)\n        assert await error_locator.is_visible(), 'Expected error message is not visible after failed login attempt.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055100898055//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.876Z",
    "modified": "2025-09-16T20:38:21.046Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "64292f6b-4c17-4f7b-9302-89e3d8956643",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC003-Login with Google OAuth",
    "description": "Ensure users can log in successfully via the Google OAuth method and are sent to the correct dashboard per their role.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking 'Acessar Sistema' button to see if it leads to login options or Google OAuth.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Since the expected result is unknown and the test plan execution has failed, produce a generic failing assertion\n        assert False, 'Test plan execution failed: unable to verify user authentication and dashboard redirection.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to runtime error caused by invalid environment variables on the dashboard page. Unable to proceed with Google OAuth login testing or verify user redirection to dashboards.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=vusbg:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=fsnpp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)\n[WARNING] [Fast Refresh] performing full reload because your application had an unrecoverable error (at webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/dev/hot-reloader/pages/hot-reloader-pages.js:347:24)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054982164928//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.885Z",
    "modified": "2025-09-16T20:36:22.359Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "ce3fe781-ed0f-4346-99ce-5e90425ebb58",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC004-Login with Magic Link Functionality",
    "description": "Validate login flow via Magic Link sent to user email works properly and redirects to role-based dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the 'Fazer Login' button to navigate to the login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try alternative navigation by clicking the 'Login' link (index 13) to access the login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/footer/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter registered email in the email input and click 'Receber link por email' button to request Magic Link.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('usuario@exemplo.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login flow via Magic Link cannot be fully tested because the system returns an unexpected authentication error when requesting the Magic Link. The issue prevents proceeding further. Reporting this issue and stopping the test as per instructions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055103857603//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.896Z",
    "modified": "2025-09-16T20:38:24.006Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "a8ac718e-5c14-49fc-abcc-39664a33c887",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC005-Role-Based Access Control Enforcement",
    "description": "Verify that users can only access application features and UI elements allowed for their assigned roles (Admin, Fisioterapeuta, Estagiário, Paciente).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the login button to start login as Admin user.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Acessar Sistema' button to see if it leads to login or dashboard access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because the application dashboard is inaccessible due to invalid environment variables causing a runtime error. Please fix the environment configuration to enable further testing of role-based access controls.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=vusbg:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=fsnpp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)\n[WARNING] [Fast Refresh] performing full reload because your application had an unrecoverable error (at webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/dev/hot-reloader/pages/hot-reloader-pages.js:347:24)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/17580549715137//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.906Z",
    "modified": "2025-09-16T20:36:11.712Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "99318362-1074-4ca9-bd95-0724a74c1b0f",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC006-Patient Record Creation with Valid CPF and Photo Upload",
    "description": "Verify that new patient records can be created with mandatory fields including valid CPF format, secure photo upload, and compliance with LGPD.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Patient record creation verification could not be completed due to unknown expected result.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped testing due to inability to access login page. The 'Fazer Login' button is unresponsive and does not navigate to the login page, blocking the workflow for patient record creation and LGPD compliance verification.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054944487406//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.915Z",
    "modified": "2025-09-16T20:35:44.624Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "08f7c39c-e0c6-450c-966f-a46142d70727",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC007-Patient Record Creation with Invalid CPF Format",
    "description": "Verify that patient record creation is prevented if the CPF does not meet Brazilian validation rules and appropriate error is shown.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking 'Acessar Sistema' button to see if it leads to login or patient management page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test failed due to unknown expected result.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical runtime error caused by invalid environment variables on the dashboard page. Unable to access patient record creation to verify CPF validation. Please fix environment configuration to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=vusbg:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=fsnpp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)\n[WARNING] [Fast Refresh] performing full reload because your application had an unrecoverable error (at webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/dev/hot-reloader/pages/hot-reloader-pages.js:347:24)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054971142935//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.925Z",
    "modified": "2025-09-16T20:36:11.393Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "2ad2a9e2-5207-4319-a917-aa6c1d5ab089",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC008-Edit Existing Patient Record and Update Photo",
    "description": "Ensure patient records can be edited by authorized users including updating photo, and changes are saved correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical navigation issue: 'Fazer Login' button does not lead to login page, preventing authentication and further test execution.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/175805494382847//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.932Z",
    "modified": "2025-09-16T20:35:44.021Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "994b69b6-0f1a-42fa-9ef9-5b1738cfc336",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC009-Body Mapping Interactive Pain Point Registration",
    "description": "Verify users can interact with the SVG body map to add, edit, and remove pain points with correct severity on a scale from 0 to 10, and timeline updates accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login as Fisioterapeuta.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Fisioterapeuta and click 'Entrar' to log in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('fisioterapeuta@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('securepassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login using 'Entrar com Google' button or use 'Receber link por email' option to proceed with authentication.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to use 'Receber link por email' option to authenticate via email link as alternative login method.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Final generic failing assertion since expected result is unknown\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to proceed with testing body mapping interface due to persistent login failures. All login methods (email/password, Google, email link) resulted in errors preventing access. Cannot verify adding, editing, or removing pain points without authentication. Recommend resolving authentication issues before retesting.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055066343197//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.939Z",
    "modified": "2025-09-16T20:37:46.479Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "7ec733d0-cfb1-4867-9d04-5b5295259f15",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC010-Create Appointment with Conflict Prevention",
    "description": "Verify the appointment system prevents scheduling conflicts by validating the availability of both patient and professional before confirming booking.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password for Fisioterapeuta and click 'Entrar' to log in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('fisioterapeuta@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('securepassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login using 'Entrar com Google' button or verify credentials and retry login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to reset password using 'Esqueci minha senha' link or request access via 'Solicitar acesso' to regain account access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[3]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: appointment scheduling conflict not handled as expected.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed due to critical authentication issues: login failures and broken password reset functionality. Reported these issues for resolution. Task stopped.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password?_rsc=vhvvv:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055049345783//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.945Z",
    "modified": "2025-09-16T20:37:29.484Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "68e53a50-91a6-4c85-aa6d-8e72f7a7b55d",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC011-Appointment Waiting List and Notification Delivery",
    "description": "Verify that when all slots are taken, users can join a waiting list and receive notifications when a slot becomes available.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: generic failure assertion as expected result is unknown.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to unresponsive 'Fazer Login' button preventing access to login page and booking system. Cannot verify waiting list functionality without login.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054950483797//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.954Z",
    "modified": "2025-09-16T20:35:50.631Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "829ef14e-ee49-43b3-98d0-14adfd9fa68b",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC012-Document Physiotherapy Session with Pain Level and Exercise Prescription",
    "description": "Verify that during session documentation users can record pain levels, procedures performed, prescribe exercises and schedule return visits properly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the login button to start login as Fisioterapeuta.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Acessar Sistema' button to see if it leads to the login page or login form.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down or navigate to find patient sessions list or button to create a new session.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed due to critical runtime error 'Invalid environment variables' on the dashboard page. Please fix the environment configuration to enable further testing of session documentation features.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=vusbg:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)\n[WARNING] [Fast Refresh] performing full reload because your application had an unrecoverable error (at webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/dev/hot-reloader/pages/hot-reloader-pages.js:347:24)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/175805498273865//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.961Z",
    "modified": "2025-09-16T20:36:22.919Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "4d431519-0210-49d1-8478-7925f5d3042e",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC013-Exercise Library Search and Filtering",
    "description": "Verify the exercise library supports categorization by body region and exercise type, enables search, and filtering by difficulty levels.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Acessar Sistema' button to enter the main system where exercise library should be accessible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical runtime error 'Invalid environment variables' blocking access to the exercise library and main system. Please fix environment configuration to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=vusbg:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=fsnpp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard?_rsc=fsnpp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/dashboard:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054901494057//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.968Z",
    "modified": "2025-09-16T20:35:01.701Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "322ad6b8-ca64-4631-8a13-664af9bd7d4e",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC014-Patient Portal Access to Prescribed Exercises and Adherence Reporting",
    "description": "Ensure patients can view exercises prescribed to them and provide feedback on exercise adherence via the portal with accurate reporting.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to start login as Paciente.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The critical issue with the 'Fazer Login' button being unresponsive has been reported. Due to this, it is not possible to proceed with logging in as Paciente, accessing prescribed exercises, or submitting feedback. The task is now complete with this issue documented.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054954433354//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.977Z",
    "modified": "2025-09-16T20:35:54.623Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "64aeb5b2-0f0d-4fb2-a9f4-f32e7e98f2da",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC015-Dashboards Display Correct Metrics by User Role",
    "description": "Verify that dashboards render accurate key performance indicators and metrics tailored for Admin, Fisioterapeuta, Estagiário, and Paciente roles.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Login' link (index 13) to access the login page or consider direct URL navigation if no other clickable login elements exist.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/footer/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input Admin email and password, then click 'Entrar' button to log in.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AdminPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login with other user roles (Fisioterapeuta, Estagiário, Paciente) if credentials are available, or report authentication issue and stop.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('fisioterapeuta@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('FisioPass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login with Estagiário role if credentials are available, or report authentication issue and stop.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('estagiario@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('EstagioPass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login with Paciente role if credentials are available, or report authentication issue and stop.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('paciente@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('PacientePass123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: dashboard metrics verification could not be completed.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "All login attempts for the user roles Admin, Fisioterapeuta, Estagiário, and Paciente failed due to an unexpected authentication error. As a result, it was not possible to access the dashboards to verify the key performance indicators and metrics for each role. The issue appears to be with the authentication system or credentials. Further testing cannot proceed until this is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055333751673//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.985Z",
    "modified": "2025-09-16T20:42:13.954Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "34e1d0fc-23fd-4a15-990a-0eefa3370631",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC016-Generate and Export Customized Clinical and Financial Reports",
    "description": "Verify reports are generated with accurate data, can be customized by filters, and exported correctly into PDF and other professional formats.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed to login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input admin email and password, then click 'Entrar' to login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('AdminPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to login using 'Entrar com Google' button or reset password if possible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Esqueci minha senha' link to initiate password reset process.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[3]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to login as admin or authorized user. Authentication failures and broken password reset link prevent access to reporting section. Cannot verify report generation, filtering, or export functionalities. Please resolve login issues to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password?_rsc=vhvvv:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055045733817//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:28.993Z",
    "modified": "2025-09-16T20:37:25.863Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "6ce664f5-5c8c-45f4-911e-8502e7296267",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC017-Data Security and Encryption Compliance",
    "description": "Verify sensitive data including patient information is encrypted at rest and in transit complying with LGPD standards and audit logs are consistently generated.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to access the system and verify database and network encryption.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: Unable to verify encryption and audit logs compliance.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue that the login page is inaccessible via the 'Fazer Login' button, preventing further testing of encryption and audit logs. Stopping the task as system access is required for verification.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054939289977//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:29.000Z",
    "modified": "2025-09-16T20:35:39.456Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "8df5f117-01bc-45db-a974-9fef0fba89ec",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC018-UI Accessibility and Brazilian Market Compliance",
    "description": "Ensure UI components based on Radix UI and Tailwind CSS are accessible (keyboard navigation, ARIA attributes) and formatted per Brazilian localization standards.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Start inspecting keyboard navigability on main interactive buttons like 'Entrar', 'Dashboard', 'Acessar Sistema', and 'Fazer Login'.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/header/div/div/div[2]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The 'Entrar' button on the homepage is unresponsive and does not navigate or change the page state. This blocks further accessibility testing and user interaction. Reporting this as a critical issue and stopping further actions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758054958720058//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:29.008Z",
    "modified": "2025-09-16T20:35:58.882Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "504f010b-d1d8-42b1-aa01-0a22250e7951",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC019-Error Handling and User Feedback on API Failures",
    "description": "Simulate API failures and verify the system handles errors gracefully with user-friendly messages and logs errors appropriately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to access the login page and prepare for testing save operations with failure simulation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input valid email and password, then click 'Entrar' to login and access the system for further testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teste@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SenhaForte123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped testing due to authentication failure blocking access to the system. Cannot proceed with API failure simulation and error handling verification without successful login.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/175805502789135//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:29.015Z",
    "modified": "2025-09-16T20:37:08.060Z"
  },
  {
    "projectId": "6a433318-04c1-4906-bf08-bdee06894e66",
    "testId": "20593579-bf71-4425-871a-1396270fef3e",
    "userId": "e4283488-7051-707c-11ef-c2c52f8a0848",
    "title": "TC020-End-to-End Workflow: Scheduling, Session Documentation and Reporting",
    "description": "Test complete workflow from appointment scheduling, patient session documentation, updating pain mapping, prescribing exercises, to generating final reports.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Fazer Login' button to proceed with authentication.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/section/div/div/div/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email and password, then click 'Entrar' to login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teste@fisioflow.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('SenhaForte123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to use 'Receber link por email' option to login or recover access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt login using 'Entrar com Google' button as alternative authentication method.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try 'Esqueci minha senha' (Forgot password) flow to reset password and regain access.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/form/div[3]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical authentication failures and missing password reset page. Unable to proceed with appointment scheduling, session documentation, pain mapping, exercise prescription, and report generation. Please fix authentication issues and password reset flow to enable further testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/login:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password?_rsc=vhvvv:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/forgot-password:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283488-7051-707c-11ef-c2c52f8a0848/1758055096949654//tmp/test_task/result.webm",
    "created": "2025-09-16T20:33:29.024Z",
    "modified": "2025-09-16T20:38:17.105Z"
  }
]
